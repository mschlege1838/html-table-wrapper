<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: SimpleDataTableListener.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
	<link type="text/css" rel="stylesheet" href="styles/style.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: SimpleDataTableListener.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Callbacks
/**
 * Called by {@link SimpleDataTableListener} to obtain a {@link ColumnControl} for a given column. If a value is returned, it will be used as the 
 * control for that column. If {@link Nothing} is returned, the default control ({@link SimpleDataTableControl}) will be created and used 
 * for that column.
 *
 * @callback SimpleDataTableListener~getColumnControl
 * @param {number} columnIndex Column index for which a {@link ColumnControl} is needed.
 * @param {SimpleDataTableListener} parent The {@link SimpleDataTableListener} requesting a control.
 * @returns {ColumnControl} A {@link ColumnControl} if a client-defined control is needed for the given `columnIndex`, otherwise {@link Nothing}.
 */

// Virtual Interfaces
// ColumnControlFactory
/**
 * @interface ColumnControlFactory
 * @classdesc
 *   Object-based implementation of {@link SimpleDataTableListener~getColumnControl}.
 */
/**
 * Implementation of {@link SimpleDataTableListener~getColumnControl}. See the callback's documentation for further details.
 *
 * @function ColumnControlFactory#getColumnControl
 * @param {number} columnIndex Column index for which a {@link ColumnControl} is needed.
 * @param {SimpleDataTableListener} parent The {@link SimpleDataTableListener} requesting a control.
 * @returns {ColumnControl} A {@link ColumnControl} if a client-defined control is needed for the given `columnIndex`, otherwise {@link Nothing}.
 */

// ColumnControl
/**
 * @interface ColumnControl
 * @extends Disposable
 * @classdesc
 *
 * A handle used by {@link SimpleDataTableListener} to open and close controls in response to client calls and end-user requests. 
 * Client code can define custom controls by implementing this interface and returning instances via an implementation of
 * {@link ColumnControlFactory}.
 */ 
/**
 * Index of the column this `ColumnControl` handles.
 *
 * @member {number} ColumnControl#columnIndex
 */
/**
 * Opens this `ColumnControl` such that it is visible to the end-user.
 *
 * @function ColumnControl#open
 */
/**
 * Closes this `ColumnControl` such that it is hidden from the end-user.
 *
 * @function ColumnControl#close
 */
/**
 * Called by {@link SimpleDataTableListener#processTable} to obtain a {@link FilterDescriptor} based upon the current state of this
 * `ColumnControl`. If this control is in a state in which no filtering should be performed, it is permissible to return {@link Nothing}.
 *
 * @function ColumnControl#getFilterDescriptor
 * @returns {FilterDescriptor} 
 *   A {@link FilterDescriptor} based upon the state of this `ColumnControl` or {@link Nothing} if no filtering should be performed.
 */
/**
 * Called by {@link SimpleDataTableListener#processTable} to obtain a {@link SortDescriptor} based upon the current state of this
 * `ColumnControl`. If this control is in a state in which no sorting should be performed, it is permissible to return {@link Nothing}.
 *
 * @function ColumnControl#getSortDescriptor
 * @returns {SortDescriptor}
 *   A {@link SortDescriptor} based upon the state of this `ColumnControl` or {@link Nothing} if no sorting should be performed.
 */

 
 

// Constructor
/**
 * @constructor
 * @implements Disposable
 * @param {(HTMLTableElement|SimpleDataTable)} table `HTMLTableElement` or {@link SimpleDataTable} backing this listener.
 * @param {ColumnControlFactory|SimpleDataTableListener~getColumnControl} [columnControlFactory] Optional factory if custom column controls are needed.
 * @classdesc
 *
 * Facilitates communication between the API-level {@link SimpleDataTable} and the UI-level {@link ColumnControl}. In addition to the constraints
 * placed on the backing `HTMLTableElement` in {@link SimpleDataTable}, this class also requires it to define a table header section
 * (`&lt;thead>`) with the first row's cells defining the column headers for the table. Although the table can define more than one row in its table
 * header section, only the first row will be processed by this class.
 * 
 * Upon {@link SimpleDataTableListener#init initialization}, this class will add itself as a listener for click events on
 * all cells in the first row of the backing `HTMLTableElement`'s table header section, as well as add the class name
 * {@link SimpleDataTableListener.processedColumnHeader} to each cell.
 * 
 * In response to click events, the appropriate {@link ColumnControl} will be created using the given {@link ColumnControlFactory} (or {@link SimpleDataTableListener~getColumnControl} 
 * callback), if defined, or will fall back to {@link SimpleDataTableControl} in the case no {@link ColumnControlFactory} (or callback) is defined, or the call to 
 * {@link ColumnControlFactory#getColumnControl} (or direct invocation of the {@link SimpleDataTableListener~getColumnControl} callback) returns {@link Nothing}. {@link ColumnControl}s 
 * are cached after they are created, and are reused for subsequent click events.
 * 
 * {@link ColumnControl}s can make calls back to {@link SimpleDataTableListener#processTable} to trigger table-wide
 * sorting and filtering in response to user-triggered events on the control that would be expected to update the state of the 
 * backing table. Upon a call to {@link SimpleDataTableListener#processTable}, {@link ColumnControl#getFilterDescriptor} and 
 * {@link ColumnControl#getSortDescriptor} are called for each cached {@link ColumnControl}. Each result that is not {@link Nothing} is stored, 
 * and ultimately passed to {@link SimpleDataTable#filter} and {@link SimpleDataTable#sort}. (Implicit to this, calls to {@link SimpleDataTableListener#processTable}
 * should not be made in {@link ColumnControl#getFilterDescriptor} and {@link ColumnControl#getSortDescriptor}, as such would cause infinite recursion).
 */
function SimpleDataTableListener(table, columnControlFactory) {
	'use strict';
	
	if (table instanceof SimpleDataTable) {
		this.dataTable = dataTable;
	} else {
		this.dataTable = new SimpleDataTable(table);
	}
	
	/**
	 * {@link ColumnControlFactory} to use when creating controls.
	 *
	 * @type ColumnControlFactory
	 * @private
	 */
	this.columnControlFactory = columnControlFactory;
	
	/**
	 * Cache of `HTMLTableCellElement`s for which this class is registered for click events.
	 *
	 * @private
	 * @type {HTMLTableCellElement[]}
	 */
	this.tableHeaderCache = [];
	
	/**
	 * {@link ColumnControl} cache.
	 *
	 * @private
	 * @type {ColumnControl[]}
	 */
	this.columnControls = [];
}

// Static fields.
/**
 * Class name added to `HTMLTableCellElement`s upon which `SimpleDataTableListener` instances are registered for
 * click events. Default value is `'data-table-column-header'`.
 *
 */
SimpleDataTableListener.processedColumnHeader = 'data-table-column-header';

// Instance Properties
/**
 * Backing {@link SimpleDataTable}.
 *
 * @member {SimpleDataTable} SimpleDataTableListener#dataTable
 * @private
 */
 
 
/**
 * Current column-order in which to apply sort descriptors. Initially `null`, initialized on first call to {@link SimpleDataTableListener#processTable}.
 *
 * @private
 * @type {number[]}
 */
SimpleDataTableListener.prototype.sortDescriptorOrder = null;

// Instance Methods
/**
 * Initializes this `SimpleDataTableListener`. This `SimpleDataTableListener` will be added as a click listener for each `HTMLTableCellElement` 
 * in the first row of the backing table's header section. The class name {@link SimpleDataTableListener.processedColumnHeader} will also be added to
 * each cell.
 */
SimpleDataTableListener.prototype.init = function () {
	'use strict';
	
	var table, tableHeaders, tableHeaderCache, i, tableHeader;
	
	table = this.dataTable.getTableElement();
	tableHeaders = table.tHead.rows[0].cells;
	tableHeaderCache = this.tableHeaderCache = [];
	
	
	for (i = 0; i &lt; tableHeaders.length; ++i) {
		tableHeader = tableHeaders[i];
		IE8Compatibility.addEventListener(tableHeader, 'click', this, false);
		IE8Compatibility.addClass(tableHeader, SimpleDataTableListener.processedColumnHeader);
		tableHeaderCache.push(tableHeader);
	}
	
};

/**
 * Disposes this `SimpleDataTableListener`. This `SimpleDataTableListener` will remove itself as a click listener for any
 * `HTMLTableCellElement`s upon which it has registered itself, as well as remove the {@link SimpleDataTableListener.processedColumnHeader}
 * class name. Additionally, if any cached {@link ColumnControl}s define a {@link ColumnControl#dispose dispose} function, it will also be called.
 */
SimpleDataTableListener.prototype.dispose = function () {
	'use strict';
	
	var tableHeaderCache, i, columnControls, columnControl, tableHeader;
	
	tableHeaderCache = this.tableHeaderCache;
	for (i = 0; i &lt; tableHeaderCache.length; ++i) {
		tableHeader = tableHeaderCache[i];
		IE8Compatibility.removeEventListener(tableHeader, 'click', this, false);
		IE8Compatibility.removeClass(tableHeader, SimpleDataTableListener.processedColumnHeader)
	}
	
	columnControls = this.columnControls;
	for (i = 0; i &lt; columnControls.length; ++i) {
		columnControl = columnControls[i];
		if (typeof columnControl.dispose === 'function') {
			columnControl.dispose();
		}
	}
	
};

/**
 * Implementation of DOM `EventListener`.
 *
 * @param {Event} event Event being dispatched.
 */
SimpleDataTableListener.prototype.handleEvent = function (event) {
	'use strict';
	
	var columnIndex, target;
	
	// Only process click events (warn otherwise).
	if (event.type !== 'click') {
		if (console &amp;&amp; console.warn) {
			console.warn('Unsupported event: ' + event.type);
			console.warn(event);
		}
		return;
	}
	
	// Get column index.
	target = IE8Compatibility.getEventTarget(event);
	columnIndex = this.tableHeaderCache.indexOf(target);
	if (columnIndex === -1) {
		if (console &amp;&amp; console.warn) {
			console.warn('Unrecognized event target.');
			console.warn(target);
		}
		return;
	}
	
	// Open control
	this.openColumnControl(columnIndex);
};

/**
 * Opens the {@link ColumnControl} for the given `columnIndex`. Delegates to {@link SimpleDataTableListener#getColumnControl}
 * to obtain the {@link ColumnControl} to be opened. After obtained, {@link ColumnControl#open} will be called on it, and 
 * {@link ColumnControl#close} on all others in the cache.
 *
 * @param {number} columnIndex Index of the column upon which a {@link ColumnControl} is to be opened.
 * @throws {RangeError} If `columnIndex` is greater than or equal to the number of columns in the backing table.
 */
SimpleDataTableListener.prototype.openColumnControl = function (columnIndex) {
	'use strict';
	
	var tableHeader, targetColumnControl, columnControls, columnControl, i;
	
	targetColumnControl = this.getColumnControl(columnIndex);
	
	columnControls = this.columnControls;
	for (i = 0; i &lt; columnControls.length; ++i) {
		columnControl = columnControls[i];
		if (columnControl === targetColumnControl) {
			columnControl.open();
		} else {
			columnControl.close();
		}
	}
};

/**
 * Obtains a {@link ColumnControl} for the given `columnIndex`. If one is cached (has been obtained before), it will be returned.
 * Otherwise it will be created using the {@link ColumnControlFactory} passed to the constructor of this `SimpleDataTableListener`. If defined, and its
 * {@link ColumnControlFactory#getColumnControl} function returns a value that is not {@link Nothing}, that value will be cached and returned. Failing that,
 * a new {@link SimpleDataTableControl} will be cached and returned.
 *
 * @param {number} columnIndex Index of the column for which a {@link ColumnControl} is to be obtained.
 * @throws {RangeError} If `columnIndex` is greater than or equal to the number of columns in the backing table.
 * @returns {ColumnControl} The newly created, or previously cached {@link ColumnControl} for the given `columnIndex`.
 */
SimpleDataTableListener.prototype.getColumnControl = function (columnIndex) {
	'use strict';
	
	var columnControls, columnControl, currentColumnControl, i, columnControlFactory, columnCount;
	
	if (columnIndex > (columnCount = this.tableHeaderCache.length)) {
		throw new RangeError('The given columnIndex must be less than the number of columns in the backing table (' + columnCount + '): ' + columnIndex);
	}
	
	columnControls = this.columnControls;
	for (i = 0; i &lt; columnControls.length; ++i) {
		currentColumnControl = columnControls[i];
		if (currentColumnControl.columnIndex === columnIndex) {
			return currentColumnControl;
		}
	}

	
	columnControlFactory = this.columnControlFactory;
	if (columnControlFactory) {
		columnControl = typeof columnControlFactory.getColumnControl === 'function' ? 
				columnControlFactory.getColumnControl(columnIndex, this) : columnControlFactory(columnIndex, this);
	}
	
	if (!columnControl) {
		columnControl = new SimpleDataTableControl(columnIndex, this);
	}
	
	if (typeof columnControl.init === 'function') {
		columnControl.init();
	}
	
	columnControls.push(columnControl);
	return columnControl;
};


/**
 * {@link SimpleDataTable#filter Filters} and {@link SimpleDataTable#sort sorts} the backing table based upon
 * the state of cached {@link ColumnControl}s.
 *
 * The {@link ColumnControl#getFilterDescriptor} and {@link ColumnControl#getSortDescriptor} functions are called for each
 * cached {@link ColumnControl} in the order they are created. Each result that is not {@link Nothing} is stored in a distinct
 * `Array` (one for {@link FilterDescriptor}s, another for {@link SortDescriptor}s), and subsequently passed to the backing
 * {@link SimpleDataTable}'s {@link SimpleDataTable#filter} and {@link SimpleDataTable#sort} functions. Filtering is performed before sorting.
 * 
 * {@link SortDescriptor}s are ordered according to the order in which they are/were returned from this and previous calls. E.g., consider
 * the following sequence of calls to `processTable`:
 *   1. A valid {@link SortDescriptor} is returned for column 1 => table will be ordered by column 1
 *   2. A valid {@link SortDescriptor} is returned for columns 1 and 2 => table will be ordered by columns 1, 2
 *   3. A valid {@link SortDescriptor} is returned for columns 1, 2, and 3 => table will be ordered by columns 1, 2, 3
 *   4. A valid {@link SortDescriptor} is only returned for columns 2 and 3 => table will be ordered by columns 2, 3
 *   5. A valid {@link SortDescriptor} is returned for columns 1, 2, and 3 again => table will be ordered by columns 2, 3, 1
 *
 */
SimpleDataTableListener.prototype.processTable = function () {
	'use strict';
	
	var sortDescriptors, filterDescriptors, columnControls, i, columnControl, dataTable, filterDescriptor,
		sortDescriptor, sortDescriptorOrder, columnIndex, j, targetIndex;
	
	
	// Get descriptors.
	filterDescriptors = [];
	sortDescriptors = [];
	columnControls = this.columnControls;
	for (i = 0; i &lt; columnControls.length; ++i) {
		columnControl = columnControls[i];
		
		filterDescriptor = columnControl.getFilterDescriptor();
		if (filterDescriptor) {
			filterDescriptors.push(filterDescriptor);
		}
		
		sortDescriptor = columnControl.getSortDescriptor();
		if (sortDescriptor) {
			sortDescriptors.push(sortDescriptor);
		}
	}
	
	
	// Determine order for sort descriptors.
	sortDescriptorOrder = this.sortDescriptorOrder;
	if (!sortDescriptorOrder) {
		sortDescriptorOrder = this.sortDescriptorOrder = [];
	}
	
	// Add column indicies to order that were returned, but not present.
	for (i = 0; i &lt; sortDescriptors.length; ++i) {
		columnIndex = sortDescriptors[i].columnIndex;
		if (sortDescriptorOrder.indexOf(columnIndex) === -1) {
			sortDescriptorOrder.push(columnIndex);
		}
	}
	
	// Remove column indicies from order that are present, but not returned
	for (i = 0; i &lt; sortDescriptorOrder.length; ++i) {
		columnIndex = sortDescriptorOrder[i];
		
		targetIndex = -1;
		for (j = 0; j &lt; sortDescriptors.length; ++j) {
			if (sortDescriptors[j].columnIndex === columnIndex) {
				targetIndex = j;
				break;
			}
		}
		
		if (targetIndex === -1) {
			sortDescriptorOrder.splice(i, 1);
			--i;
		}
	}
	
	// Sort sort descriptors according to order.
	sortDescriptors.sort(function (a, b) {
		return sortDescriptorOrder.indexOf(a.columnIndex) - sortDescriptorOrder.indexOf(b.columnIndex);
	});
	
	
	
	// Process backing table.
	dataTable = this.dataTable;
	
	dataTable.filter(filterDescriptors);
	dataTable.sort(sortDescriptors);
};


/**
 * Returns this `SimpleDataTableListener`'s backing {@link SimpleDataTable}.
 *
 * @returns {SimpleDataTable} This `SimpleDataTableListener`'s backing {@link SimpleDataTable}.
 */
SimpleDataTableListener.prototype.getDataTable = function () {
	'use strict';
	
	return this.dataTable;
};


/**
 * Returns the `HTMLTableCellElement` acting as the column header for the given `columnIndex`.
 *
 * @param {number} columnIndex Index of the column header to be retrieved.
 * @returns {HTMLTableCellElement} The `HTMLTableCellElement` acting as the column header for the given `columnIndex`.
 * @throws {RangeError} If `columnIndex` is greater than or equal to the number of columns in the backing table.
 */
SimpleDataTableListener.prototype.getTableHeaderElement = function (columnIndex) {
	'use strict';
	
	return this.dataTable.getTableElement().tHead.rows[0].cells[columnIndex];
};


</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ContextControl.html">ContextControl</a></li><li><a href="ContextControl.MobileViewState.html">MobileViewState</a></li><li><a href="ContextControl.OffsetCoordinates.html">OffsetCoordinates</a></li><li><a href="IE8Compatibility.html">IE8Compatibility</a></li><li><a href="IE8Compatibility.IE8EventHandler.html">IE8EventHandler</a></li><li><a href="IE9Compatibility.html">IE9Compatibility</a></li><li><a href="IEGeneralCompatibility.html">IEGeneralCompatibility</a></li><li><a href="SimpleDataTable.html">SimpleDataTable</a></li><li><a href="SimpleDataTableControl.html">SimpleDataTableControl</a></li><li><a href="SimpleDataTableControl.ColumnValueFilter.html">ColumnValueFilter</a></li><li><a href="SimpleDataTableListener.html">SimpleDataTableListener</a></li><li><a href="SimpleDataTableUtils.html">SimpleDataTableUtils</a></li><li><a href="SimpleEventDispatcher.html">SimpleEventDispatcher</a></li><li><a href="SimpleEventDispatcher.SimpleEvent.html">SimpleEvent</a></li><li><a href="SimpleFilterDescriptor.html">SimpleFilterDescriptor</a></li><li><a href="SimpleSortDescriptor.html">SimpleSortDescriptor</a></li><li><a href="XMLBuilder.html">XMLBuilder</a></li></ul><h3>Interfaces</h3><ul><li><a href="CellInterpreter.html">CellInterpreter</a></li><li><a href="ColumnControl.html">ColumnControl</a></li><li><a href="ColumnControlFactory.html">ColumnControlFactory</a></li><li><a href="Disposable.html">Disposable</a></li><li><a href="FilterDescriptor.html">FilterDescriptor</a></li><li><a href="MinimalList.html">MinimalList</a></li><li><a href="Nothing.html">Nothing</a></li><li><a href="SimpleEventIntf.html">SimpleEventIntf</a></li><li><a href="SimpleEventListener.html">SimpleEventListener</a></li><li><a href="SortDescriptor.html">SortDescriptor</a></li></ul><h3>Events</h3><ul><li><a href="ContextControl.html#event:event:create">create</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sun Jan 26 2020 10:04:47 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
